# Cifras por bloco
Este tipo de cifras **processa mensagens com tamanho fixo 8(bloco)**. 

As regras de segurança necessisam de um numero pseudo-aleatório, **PRP**.

# Desenho das cifras de bloco
As cifras de bloco devem ter as seguintes propriedadades:
- **Difusao**: A influencia de mudanças que ocorram no plaintext devem se repercutir no ciphertext.
- **Confusao**: Relações entre o ciphertext e a key devem ser o mais complexo possível.

Nas cifras mais modernas existe uma funçao bibetiva que é aplicada repedidaemente a distintas round-keys, derivadasww da main cipher key.


# Block vs Stream Ciphers
- A unidade de processamento numa é o bloco e noutra é o bit/byte.
- O uso de cifras de bloco depende do **modo de operação**.
- As cifras nao levam a diffusao.
- O reverse de cifras de bloco é mais complicado.
- As stream ciphers sao em geral mais rapidas que as block ciphers.

# Modos de operaçao básicos
Descreve como a primitiva encripta/decripta as mensagens arbitrarias.
- Eletronic Code Bokk (ECB)
- Cipher Block Chaining (CBC)
- Counter Mode (CTR)

# Padding
Algumas cifras de bloco requerem o tamanho do plaintext seja multiplo do block size.  O padding é um metodo **reversível** que preenche os ultimos plocoss do plaintext. Pode ser orinetado ao bit ou byte. Pode ser determinista ou random. Um exemplo é o **PKCS7**. Uma alternativa ao padding é **Ciphertext Stealing**.

# ECB
![ECB](/Images/3-ECB.png)

Nesse modo, cada bloco de texto simples é cifrado independentemente usando a mesma chave, resultando em uma saída de texto cifrado que é idêntica para blocos idênticos de texto simples. Isso pode tornar o ECB suscetível a certas vulnerabilidades, como revelação de padrões nos dados originais. Neste sentido, deve ser unicamente usado para encriptar cifras com apenas uma bloco. Usa padding.

# CBC
![CBC](/Images/4-CBC.png)
Cada plaintext é misturado com o anterior ciphertext, introduzindo uma dependencia entre blocos. É necessário um **Initialisation Vector(IV)** random para iniciar o processo. **Tal como os nonces, o iv nao precisa de ser secreto**. Um bit alterado no ciphertext irá impactar o correspondente bit do bloco seguinte. O ultimo bloco pode ser usado como a Message Authentication Code (CBC-MAC). è usado para mensagens de tamanho fixo.

# OFB - Output FeedBack mode
![OFB](/Images/5-OFB.png)
Implementa uma stream cipher sincronizada. O bloco cifrado é usado como proxima funcao. Output function é a funcao identidade. Não precisa de padding. IV normalmente é um Nonce. A stream nao depende da mensagem. É obtida por iteração da cifra de bloco e o IV. Swappign the 1 bit apenas impacta esse bit.

---

O modo OFB cifra um vetor de inicialização para gerar uma sequência de chaves que são então usadas para cifrar o texto plano. Isso significa que alterações nos blocos cifrados não afetam os blocos seguintes, proporcionando uma melhor propagação de erros.

# CTR - CounTeR mode 
![CTR](/Images/6-CTR.png)
Implementa a stream cipher sincronizada. A next-state function é um simples incremento. A block cipher é usada como output-function. Não necessita de padding. IV costuma ser um nonce. A keystream nao depende das mensagens, uma vez que cada bloco pode ser processado independentemente. A troca de 1 bit apenas afeta esse bit.

---

Neste modo, um contador é usado para gerar uma sequência de chaves que são então XORed com o texto plano para produzir o texto cifrado. Isso permite paralelismo e é frequentemente usado em implementações de criptografia em hardware.

# Autenticidade
Mais recentemente, têm adotado modos de operação que garnatam nao só a **confidencialidade** como a **integridade/autenticidade** dos dados. Usam dados que nao sao incriptados mas que tao adicionados para garantir a integridade dos dados. Alguns exemplos sao:
- EAX (Encrypt-the-Mac-then-Translate)
- CCM (Counter with CBC-MAC)
- GCM (Galois/Counter Mode)
- OCB (Offset CodeBook)

# Advanced Encryption Standard (AES)
- Blocos e Keys com pelo menos 128bits.
- Mais rapido e seguro que o TripleDES.
- Especificação detalhada e design racional.
- Adequado a software 32bits.
Quem ganhou a competição foi o RijnDael pelo seu design claro, por ser rapido, e por ter uma boa segurança.

# AES com RijnDael
Blocos de 128 bits, organizados numa matriz 4x4. Tem uma cifra itarativa, que depende co numero de rounds. Suporta chaves de 128,192 e 256 bits. Existem vários round processing steps que pode ter como, subBytes, shiftRows, mixColumns, addKey.

---

O AES opera em blocos de dados de 128 bits e utiliza chaves de 128, 192 ou 256 bits. O tamanho da chave determina o nível de segurança oferecido pelo algoritmo.

O AES executa uma série de "rounds" (rondas) de operações criptográficas. O número de rounds varia dependendo do tamanho da chave: 10 rounds para chave de 128 bits, 12 rounds para chave de 192 bits e 14 rounds para chave de 256 bits.

1. Durante cada round, os bytes do bloco de dados são substituídos por outros bytes de acordo com uma tabela de substituição conhecida como a S-Box. Essa etapa é chamada de SubBytes.
![ByteSub](/Images/7-ByteSub.png)

2. Em seguida, as linhas do bloco de dados são deslocadas circularmente de acordo com um padrão específico. Esta etapa é chamada de ShiftRows.
![ShiftRow](/Images/8-ShiftRow.png)

3. Cada coluna do bloco de dados é transformada linearmente por uma operação de multiplicação de matriz. Esta etapa é chamada de MixColumns.
![MixColumn](/Images/9-MixColumn.png)

4. Finalmente, uma chave de round é combinada com o bloco de dados usando a operação XOR (ou exclusiva). Esta etapa é chamada de AddRoundKey.
![KeyAddition](/Images/10-KeyAddition.png)

Essas operações são repetidas para o número de rounds especificado, exceto para a última round onde a etapa MixColumns é omitida.

# One-Way Functions
É facil de obter f(A) mas dificil de obter a sua inversa. Estas funções tem como exemplo hash functions. Cada entrada deve gerar um hash único. Embora seja teoricamente possível ter colisões (duas entradas diferentes que geram o mesmo hash), funções de hash modernas são projetadas para minimizar essa possibilidade. Em OW, decobrir colicoes é dificil.

# Defining properties
Os requerimentos de uma função de hash sao usualmente expressos por uma hierarquia de propriedades:
1. **(First) pre-image resistant**: Dado o valor de hash, deve ser impossivel de obter a mensagem m (H(m)=h).
2. **Second pre-image resistant**: Dado uma mensagem m1, deve ser impossivel obter uma mensagem m2 diferente de m1 tal que H(m2) = H(m1).
3. **Collision resistant**: É impraticável encontrar mensagens distintas m1 e m2 tal que H(m1) = H(m2).

# Birthday Paradox
Quantas pessoas temos de conhecer para que seja mais provavel duas nascerem no mesmo dia?
A resposta é sqrt(366).

Se nos considerarmos um codominio de 128 bits, concluimos que o birthday ataque precisa mais ou menos de 2 elevado a 64 random tentativas para encontrar uma colisao. As mais conhecidas hash functions sao:
- **MD5**: Codominio de 128bits. Já foi quebrada.
- **SHA-1**:Codominio 160bits. Já foi quebrada.
- **SHA-2**: Codominio de 256,384 e 512 bits. Mesmo dsign que o SHA-1 mas com mais segurança.
- **SHA-3**: Codominio de 256,384 e 512 bits. Tem um design diferente.
- **SHAKE-128/256**: eXtendable Output Function (XOF). The same design of
SHA-3.

