# Cifras por bloco
Este tipo de cifras **processa mensagens com tamanho fixo 8(bloco)**. 

As regras de segurança necessisam de um numero pseudo-aleatório, **PRP**.

# Desenho das cifras de bloco
As cifras de bloco devem ter as seguintes propriedadades:
- **Difusao**: A influencia de mudanças que ocorram no plaintext devem se repercutir no ciphertext.
- **Confusao**: Relações entre o ciphertext e a key devem ser o mais complexo possível.

Nas cifras mais modernas existe uma funçao bibetiva que é aplicada repedidaemente a distintas round-keys, derivadasww da main cipher key.


# Block vs Stream Ciphers
- A unidade de processamento numa é o bloco e noutra é o bit/byte.
- O uso de cifras de bloco depende do **modo de operação**.
- As cifras nao levam a diffusao.
- O reverse de cifras de bloco é mais complicado.
- As stream ciphers sao em geral mais rapidas que as block ciphers.

# Modos de operaçao básicos
Descreve como a primitiva encripta/decripta as mensagens arbitrarias.
- Eletronic Code Bokk (ECB)
- Cipher Block Chaining (CBC)
- Counter Mode (CTR)

# Padding
Algumas cifras de bloco requerem o tamanho do plaintext seja multiplo do block size.  O padding é um metodo **reversível** que preenche os ultimos plocoss do plaintext. Pode ser orinetado ao bit ou byte. Pode ser determinista ou random. Um exemplo é o **PKCS7**. Uma alternativa ao padding é **Ciphertext Stealing**.

# ECB
![ECB](/Images/3-ECB.png)

Nesse modo, cada bloco de texto simples é cifrado independentemente usando a mesma chave, resultando em uma saída de texto cifrado que é idêntica para blocos idênticos de texto simples. Isso pode tornar o ECB suscetível a certas vulnerabilidades, como revelação de padrões nos dados originais. Neste sentido, deve ser unicamente usado para encriptar cifras com apenas uma bloco. Usa padding.

# CBC
![CBC](/Images/4-CBC.png)
Cada plaintext é misturado com o anterior ciphertext, introduzindo uma dependencia entre blocos. É necessário um **Initialisation Vector(IV)** random para iniciar o processo. **Tal como os nonces, o iv nao precisa de ser secreto**. Um bit alterado no ciphertext irá impactar o correspondente bit do bloco seguinte. O ultimo bloco pode ser usado como a Message Authentication Code (CBC-MAC). è usado para mensagens de tamanho fixo.

# OFB - Output FeedBack mode
![OFB](/Images/5-OFB.png)
Implementa uma stream cipher sincronizada. O bloco cifrado é usado como proxima funcao. Output function é a funcao identidade. Não precisa de padding. IV normalmente é um Nonce. A stream nao depende da mensagem. É obtida por iteração da cifra de bloco e o IV. Swappign the 1 bit apenas impacta esse bit.

---

O modo OFB cifra um vetor de inicialização para gerar uma sequência de chaves que são então usadas para cifrar o texto plano. Isso significa que alterações nos blocos cifrados não afetam os blocos seguintes, proporcionando uma melhor propagação de erros.

# CTR - CounTeR mode 
![CTR](/Images/6-CTR.png)
Implementa a stream cipher sincronizada. A next-state function é um simples incremento. A block cipher é usada como output-function. Não necessita de padding. IV costuma ser um nonce. A keystream nao depende das mensagens, uma vez que cada bloco pode ser processado independentemente. A troca de 1 bit apenas afeta esse bit.

---

Neste modo, um contador é usado para gerar uma sequência de chaves que são então XORed com o texto plano para produzir o texto cifrado. Isso permite paralelismo e é frequentemente usado em implementações de criptografia em hardware.

# Autenticidade
Mais recentemente, têm adotado modos de operação que garnatam nao só a **confidencialidade** como a **integridade/autenticidade** dos dados. Usam dados que nao sao incriptados mas que tao adicionados para garantir a integridade dos dados. Alguns exemplos sao:
- EAX (Encrypt-the-Mac-then-Translate)
- CCM (Counter with CBC-MAC)
- GCM (Galois/Counter Mode)
- OCB (Offset CodeBook)

# Advanced Encryption Standard (AES)
- Blocos e Keys com pelo menos 128bits.
- Mais rapido e seguro que o TripleDES.
- Especificação detalhada e design racional.
- Adequado a software 32bits.
Quem ganhou a competição foi o RijnDael pelo seu design claro, por ser rapido, e por ter uma boa segurança.

# AES com RijnDael
Blocos de 128 bits, organizados numa matriz 4x4. Tem uma cifra itarativa, que depende co numero de rounds. Suporta chaves de 128,192 e 256 bits. Existem vários round processing steps que pode ter como, subBytes, shiftRows, mixColumns, addKey.

---

O AES opera em blocos de dados de 128 bits e utiliza chaves de 128, 192 ou 256 bits. O tamanho da chave determina o nível de segurança oferecido pelo algoritmo.

O AES executa uma série de "rounds" (rondas) de operações criptográficas. O número de rounds varia dependendo do tamanho da chave: 10 rounds para chave de 128 bits, 12 rounds para chave de 192 bits e 14 rounds para chave de 256 bits.

1. Durante cada round, os bytes do bloco de dados são substituídos por outros bytes de acordo com uma tabela de substituição conhecida como a S-Box. Essa etapa é chamada de SubBytes.
![ByteSub](/Images/7-ByteSub.png)

2. Em seguida, as linhas do bloco de dados são deslocadas circularmente de acordo com um padrão específico. Esta etapa é chamada de ShiftRows.
![ShiftRow](/Images/8-ShiftRow.png)

3. Cada coluna do bloco de dados é transformada linearmente por uma operação de multiplicação de matriz. Esta etapa é chamada de MixColumns.
![MixColumn](/Images/9-MixColumn.png)

4. Finalmente, uma chave de round é combinada com o bloco de dados usando a operação XOR (ou exclusiva). Esta etapa é chamada de AddRoundKey.
![KeyAddition](/Images/10-KeyAddition.png)

Essas operações são repetidas para o número de rounds especificado, exceto para a última round onde a etapa MixColumns é omitida.

# One-Way Functions
É facil de obter f(A) mas dificil de obter a sua inversa. Estas funções tem como exemplo hash functions. Cada entrada deve gerar um hash único. Embora seja teoricamente possível ter colisões (duas entradas diferentes que geram o mesmo hash), funções de hash modernas são projetadas para minimizar essa possibilidade. Em OW, decobrir colicoes é dificil.

# Defining properties
Os requerimentos de uma função de hash sao usualmente expressos por uma hierarquia de propriedades:
1. **(First) pre-image resistant**: Dado o valor de hash, deve ser impossivel de obter a mensagem m (H(m)=h).
2. **Second pre-image resistant**: Dado uma mensagem m1, deve ser impossivel obter uma mensagem m2 diferente de m1 tal que H(m2) = H(m1).
3. **Collision resistant**: É impraticável encontrar mensagens distintas m1 e m2 tal que H(m1) = H(m2).

# Birthday Paradox
Quantas pessoas temos de conhecer para que seja mais provavel duas nascerem no mesmo dia?
A resposta é sqrt(366).

Se nos considerarmos um codominio de 128 bits, concluimos que o birthday ataque precisa mais ou menos de 2 elevado a 64 random tentativas para encontrar uma colisao. As mais conhecidas hash functions sao:
- **MD5**: Codominio de 128bits. Já foi quebrada.
- **SHA-1**:Codominio 160bits. Já foi quebrada.
- **SHA-2**: Codominio de 256,384 e 512 bits. Mesmo dsign que o SHA-1 mas com mais segurança.
- **SHA-3**: Codominio de 256,384 e 512 bits. Tem um design diferente.
- **SHAKE-128/256**: eXtendable Output Function (XOF). The same design of
SHA-3.

# Aplicacoes das funções de Hash
- Verificação de passwords
- Construir blocos para outras criptograficas

# MAC - Message Authentication Code
As funções de hash, por si só, nao garantem a integridade dos dados. Para tar, usamos MAC. O MAC baseia-se numa chave que apenas é conhecida pelas partes envolvidas. O processo baseia-se em ensiar uma **tag de autenticação**. O recetor recomputa a tag e compara com a recebida. São exemplos Poly1305 e o CMAC.

# HMAC
Um MAC pode ser facilmente contruido a partir de qualquer Hash function.

O HMAC (Hash-based Message Authentication Code) é um método de autenticação de mensagem baseado em hash. Ele combina uma chave secreta com um algoritmo de hash para produzir um código de autenticação que pode ser anexado a uma mensagem. 

O HMAC recebe duas entradas: uma mensagem e uma chave secreta.

Se necessário, a chave secreta é processada para atender aos requisitos do algoritmo de hash utilizado. Isso geralmente envolve o ajuste do tamanho da chave.

Se necessário, a mensagem é preenchida para atender aos requisitos do algoritmo de hash - Padding.

A chave secreta é combinada com a mensagem (ou seu hash) de maneira específica - Combinação.
O resultado da combinação é então passado para uma função de hash, como SHA-256 ou SHA-512, produzindo um hash - Hashing.

O resultado do passo anterior é novamente combinado com a chave secreta e passado pela função de hash novamente.

O resultado final é o HMAC, que é um código de autenticação de mensagem. Ele é usado para verificar a integridade e autenticidade da mensagem, já que qualquer alteração na mensagem ou na chave resultaria em um HMAC diferente. O HMAC é especialmente útil em situações onde a mensagem e a chave devem ser transmitidas separadamente e a integridade da mensagem precisa ser verificada sem revelar a chave secreta.

O SHA-3 não é vulnerável a ataques de extensão de comprimento. Portanto, a construção aninhada do HMAC é redundante para a família de funções de hash SHA-3.

# KDF - Key-Derivation Functions 
Permite a derivação de uma chave criptografica a partir de outro segredo. É então usado em situações em que as chaves derivadas sao fracas, situacoes em que as chaves derivadas nao tenham o comprimento desejado (derivar chaves de outros tamanhos) ou em situaçeos em que se pretende derivar várias chave a partir de uma chave mestre.

# Password Baseada em KDF
As passewords nao podem ser utilizadas diretamente como chaves criptograficas, podendo no entanto derivar passwords a partir delas. O problema central é que o KDF nao resolve a fraqueza das passwords, pois tem pouca entropia e é volneravel a ataques de dicionários.

É recomendado que o KDF que usa segredos fracos, implemente **countermeasures** para minimizar os problemas mencionados. Para tal:
- Uso de **salt**: Núemro random que randomisa a saída do OW-function. Isto ajuda a defender de ataques de tabelas pré computadas.
- Uso de **resource intensive**, CPU e memória, para que os ataques sejam mais dificeis. 
Um exemplo é o **PBKDF2**.
![PBKDF2](/Images/11-PBKDF2.png)

# Proteção de passwords
Alguma aplicações requerem medidas de proteção a ataques de dicionários, tendo em conta que atacantes podem criar cracking machines e memory-hard designs.
Assim, alguns algoritmos foram criados:
- bcrypt
- SCrypt : combina o  PBKDF2 com uma construção especial (ROMix), fazendo com que ganhe resistencia a ataques de forca bruta.
- Argon2: Vencedor da Password Hashing Competition.

# Security Balance
No final das contas, a segurança depende da entropia da password.
![Security Balance](/Images/12-security_balance.png)

# Criptographic Keys
Um fator na segurança é a qualidade das chaves que são usadas. Todas elas usam Random-Number Generators.

O seu tipo(tamanho) depende da tecnica usada. Por exemplo, as chaves simétricas costumas usar random bit strings com tamanhos  entre 128 e 256 bits.

# Key handling
- As chaves devem ter o menor tempo possivel de vida. Inversamente proporcional ao seu uso e á importancia dos dados que projege.
- As chaves podem ser classificadas em **Long-term/static keys** ou **Short-term/ephemeral keys**. A criptografia simetrica opta por usar short-term keys.
- O estabelicimento que um canal seguro deve usar chaves de sessão (session keys). A **session key** é uma chave simétrica de apenas 1 uso para salvarguardar uma comunicação espeficica.
- No nivel da programação, as APIs trabalham as chaves como um tipo abstrato de dados. Permitir controle rigoroso sobre as operações disponíveis para manipulação de chaves e apoia proteções específicas (por exemplo, limpar a memória após o uso).

# Key distribution
A pré distribuição das chaves é o maior desafio da criptografia simetrica. Tipicamente dependem de canais seguros, cujos são caros.

A criptografia pode ser usada para estabelecer um canal seguro entre duas partes, mas depende da existência de  um canal seguro para distribuir a chave secreta. Isto é uma circularidade.

# Key distribution protocols
Com N users, o numero de keys que cada membro precisa de guardar para conseguir ter uma comunicação estável entre todos os membros é de (N ∗(N - 1))/2. Isto não é fiavel a uam escala maior. Assim, os protocolos de distribuiçãod e chaves fazem uso uma "rede confiavel"  para distribuir as chaves entre as partes envolvidas. 

A Trusted Third-Party (TTP) divide as chaves por cada membro. Ele gera e distribui session-keys para cada par de envolvidos. No entanto, estes protocolos nao podem ser aplicados a comunidades abertas como a Internet.

# Guidelines for key-management
- As chaves nao devem ser usadas para multiplos propositos.
- Em operaçoes criticas no que toca á segurança, o manuseamento das chaves deve ser restrito ao **Hardware Security Modules (HSM)**.
- As chaves devem ser removidas quando comprometidas ou expiradas.
- Quando um mecanismod e backup é preciso, a threshold secret-sharing scheme deve ser usado.

# Cryptographic Key-Management Systems (CKMS)
Consiste em várias politicas, componentes e dispositivos que são usados para proteger, manusear e distribuir chaves criptográficas. A CKMS cobre todos os estados que uma chave passa, desde a geração á destruição - **key lifecycle**.
![Key lifecycle](/Images/13-key_management.png)



