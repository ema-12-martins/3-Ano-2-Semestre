# Public-Key Cryptosystems
O protocolo DH sugere um mecanismo, onde dado se pretende **dividir a chave em duas componentes (key pair)**. A primeira mantém-se secreta **(secret-key (sk))** e a outra pode ser publica **(public-key (pk))**, desde que nao permita que decubram a chave secreta através dela.

- As chaves secretas nunca podem ser partilhadas.
- Não temos de garantir o segredo das chaves publicas, pelo que podem ser transmitidas em canal aberto.
- No entanto, como no DH, a autenticidade não é obtida.

# Public-Key Encryption (PKE)
- Bob gera um key-pair: (skB,pkB) = KeyGen().
- Bob manda para a Alice pkBC = Enc((pkB,M)).
- Alice encripta a mensagem para o Bob usando a usa chave publica C = Enc((pkB,M)).
- Bob decripta usando a sua chave privada M’ = Dec(skB,C).

O que obtemos é correto: Dec(skB,Enc(pkB,M)) = M

# One-way trapdoors
Numa prespetiva de seguranca, devemos ter as one-way functions com mais um requerimento, **trapdoor one-way permutation**.

Encriptar com a chave publica costuma ser uma one-way function, a menos que saibamos a chave privada.

# Man-in-the-middle (II)
O PKE nao controla o non-authentic public-keys. Esta vulnerabilidade leva a que seja possivel o Man-in-the-middle. Intruder intercepta a chave publica do Bob e troca-a pela dele. A Alice C = Enc((pkI,M)), acreditando que apenas pode ser decriptada pelo Bob. Intruder decripta usando a sua propria chave privada M’ = Dec(skI,C), e potencialmente manda para o Bob a mensagem.

Isto leva á base. Criptografia de chave assimétrica çeva a que tenha de haver autenticação.

# Hybrid Encryption
O PKE so é possivel madnar menasgens de uma estrutura específica.

A Hybrid Encryption combina uma cifra simétrica com o assimétrico PKEque encripta um random gerando a chave simétrica.

Na sua forma base, toma a estrutura de um **envelope digital**.

# KEM/DEM paradigm
Usa Hybrid Encryption e consiste em duas componentes. 

**Key Encapsulation Mechanism (KEM)**, um esquema de chave publica que é adaptado para gerar chave simetricas secretas e o seu encapsulamento com PKE. 
- KeyGen : SecParam -> (SecKey, PubKey)
- Encap: PubKey -> (SymKey, CipherText)
- Decap: (SecKey, Ciphertext) -> SymKey

**Data Encapsulation Mechanism (DEM)** um esquema simetrico que usa KEM-generated key.

---
**Key Encapsulation Mechanism (KEM)**: É um método de criptografia assimétrica no qual uma chave simétrica é encapsulada dentro de uma estrutura de dados criptografados, utilizando uma chave pública do destinatário. O destinatário pode então usar sua chave privada correspondente para descriptografar essa estrutura e recuperar a chave simétrica, que é usada para criptografar e descriptografar os dados reais.

**Data Encapsulation Mechanism (DEM)**: Refere-se ao processo de encapsular os dados que serão protegidos por criptografia. Isso envolve o uso de um algoritmo de criptografia, como AES (Advanced Encryption Standard), para embaralhar os dados de forma que só possam ser entendidos por quem possui a chave adequada para descriptografá-los.

# Digital Signatures
A assinatura garante a integridade dos dados, autenticidade e não repúdio. De relembrar que MAC satisfaz os 2 primeiros.

Deve ser capaz de saber quem produziu a assinatura, mas nunca fazer uma igual.

# Digital Signature Scheme
Temos duas entidades, o Signer e o Verifier.

Assinatura segue 3 passos:
- keyGen: secParam -> secretKey * pubKey
- sign: secretKey * message -> signature. A assinatura é junta á mensagem (M,sig).
- verify: pubKey * (message * signature) -> Bool

Propriedades para signer's key-pair (skS, pkS):
- **Correctness**: Para todo M, verify(pkS, (M, sign(skS, M)))=true
- **Security**: Sem saber skS é impossivel de forjar a assinatura para qualque mensagem verify(pkS, (M, ))=true.

# Signatures and Hashing
Com PKE, as assinaturas sao sempre combinadas com primitivas simetricas. Cryptographic Hash functions são usadas para mapear o conteudo de mensagens arbitrarias em hash values.

# Man-in-the-middle (III)
As assinaturas também sao vulneraveis ao man-in-the-middle. 

A verificação é feita com a chave publica errada, isto é falha de autenticidade.

A assinatura é supsoto levar á autenticação da mensagem. Mas a falha entre a correspondencia entre as chaves publicas e as entidades pode levar ao ataque.

Por isso, alguns acreditam no estabelicimento associado a endidade e chaves associados a um documento. A assinatura digital irá nos permitir a autenticidade desses documentos.

# Public-Key Certification
Vimos que a criptorgrafia de chave simetrica depende da correta associaçao entre chaves publicas e agentes de identificação, se garantirmos que existe uma pre distribuição das chaves publicas.

Podemos usar mecanismo de criptografia assimetrica para estabelecer public-key/identity associations.

Todos os agentes tem uma chave publica proveniente de uma agente conviável, **Certification Authority(CA)** Esta chave publica tem de ser obtida por um canal seguro.
- A CA garante a associação entre public-key/identidade, o que chamamos de **public-key certificate**. A CA é responsável por essa associação.
- Qualquer entidade pode verificar a assinatura de um certificado

# Certificate usage
O uso de certificados adiciona uma carga de gerenciamento significativa ao uso de chaves públicas.

Criação do certificado:
- Alice gera key-pair.
- Alice manda o certificado para CA que ela escolhe.
- CA verifica e valida a informação do certificado.
- CA assina o certificado e manda de volta para a Alice.

Uso do certificado:
- Quando a Alice precisa de dar ao Bob a sua chave publica, ela manda-lhe o seu certificado.
- O ob valida o certificado da Alice e consulta a chave publica contida nele.

Algumas requerimentos apenas sao viaveis a key-pair de longo-termo:
- Caso de PKE e Digital Signatures.
- Não é o caso do DH.

# Station-to-Station protocol
O DH requer key-pairs para cada execução do protocolo. Ao inves de certificar as chaves publicas do DH diretamente, alguem pode confiar nas assinaturas digitais e certificados para verificar a autenticidade de cada parte.
- A->B: +x . g^x (x valor aleatorio criado)
- B->A: +y . g^y, EK(sign(sk^B, (g^y||g^x))), Cert^B
- EK(sign(sk^A, (g^x,g^y))), Cert^A

EK(M) representa o criptograma depois de encriptado com a shared key K=g(x*y). sig(skA,M) representa a assinatura.

# Asymmetric Primitives - RSA primitive
A segurança baseia-se na dificuldade de fatorizar integers. Pode ser usado para encriptar chaves publicas a assinaturas digitais.

KeyGen():
- Gera-se 2 primos random, p e q.
- n=p*q
- Sabendo phi(n)=(p-1)*(q-1) e gcd(e,n)=1, determina-se d que e*d=1 mod phi(n).
- Retorna-se (sk, pk) onde secret-key sk = (n, d) e public-key pk = (n, e).
- RSA( pk=(n, e), m ) = me mod n 
- RSA-1( sk=(n, d), c ) = cd mod n

# RSA security
1. Derivar a chave secreta a partir da correpondente chave publica é equivalente a factoring n=p*q.
2. Inverter RSA(pk, m) é dificil sem saber sk para um random m (in the range 0 m < n).
3. Mas é facil de quebrar se m for escolhida com um pequeno espaco de mensagens, consequencia do determinism of RSA primitive (dar mensagens encriptadas repetidas sempre com o mesmo resultado de criptograma).

O modulo de 3072 bits dá a segurança de AES-128, dando degurança as chaves.

O determinismo do RSA dizem que um padding appropriado tem de ser usado.




