# Linux Security Overview
Agora vamos tentar perceber com a ajuda do chat GPT o que era suposto eu saber com os powerpoints do stor. Esperemos que ele nos ajude!

---
### Processos
Um processo é uma instância de um programa em execução num sistema operativo.

1. **Programa em Execução (Running Program)**: Um processo é criado quando um programa é carregado na memória e começa a ser executado. Cada processo é uma entidade independente que executa um conjunto de instruções definido pelo seu programa. 

2. **Espaço de Endereço Isolado (Isolated Address Space)**: Cada processo tem o seu próprio espaço de endereços na memória, isolado dos outros processos. Isto significa que um processo não pode acessar diretamente a memória de outro processo, proporcionando segurança e estabilidade ao sistema, evitando que um processo afete a execução de outro.

3. **Executado sob um ID de Utilizador e Grupo (Executed under a User and Group ID)**: Quando um processo é iniciado, ele é executado com as permissões associadas a um utilizador e a um grupo específicos. Isto define os privilégios que o processo tem, como acesso a ficheiros e outros recursos do sistema.

4. **Utilizadores Reais ou Virtuais (Actual or Virtual Users)**: O conceito de utilizadores não se limita a utilizadores físicos. Existem utilizadores virtuais, como serviços de sistema, que também podem iniciar processos. Estes utilizadores virtuais são frequentemente utilizados para tarefas automáticas e serviços do sistema operativo.

5. **IDs de Utilizador e Grupo Reais ou Efetivos (Real or Effective User and Group IDs)**: Um processo tem IDs de utilizador e grupo reais, que correspondem ao utilizador e grupo que iniciaram o processo. Além disso, existem IDs de utilizador e grupo efetivos, que podem ser temporariamente modificados para conceder ao processo permissões adicionais durante a sua execução. Este mecanismo é usado, por exemplo, quando um programa precisa realizar uma tarefa que requer privilégios superiores temporariamente.

6. **Pode Gerar Outros Processos (May Spawn Other Processes)**: Um processo pode criar (ou "spawn") outros processos, chamados processos filho. Isto é feito através de chamadas de sistema como fork ou exec em sistemas Unix-like. Os processos filho são independentes, mas podem comunicar com o processo pai e herdam parte do contexto de execução, como variáveis de ambiente.

---

### Espaço de Endereços de um Processo
O espaço de endereços de um processo é uma área de memória atribuída a um programa em execução. Este espaço de endereços é organizado de maneira tradicional e **linear**, o que significa que é estruturado de forma sequencial. 

1. **Modelo Linear Tradicional**: O espaço de endereços é organizado de forma contínua, como uma linha reta, onde diferentes partes do programa são colocadas em posições específicas.

2. **Código, Dados e Stack**: 
O **código** é a parte do espaço de endereços onde o código executável do programa é armazenado. Fica geralmente na parte inferior do espaço de endereços.

Os **dados** são a seção contém variáveis e outras informações necessárias para a execução do programa. É dividida em duas subpartes. Os **Dados Inicializados** contêm valores pré-definidos e específicos que são usados pelo programa. Os *dados Não-Inicializados (Heap) são espaços reservados para alocação dinâmica de memória durante a execução do programa.

A **Stack** situa-se na parte superior do espaço de endereços, a stack é utilizada para armazenar informações temporárias, como variáveis locais e informações de controle de chamadas de funções.

---

### Descritores do processo
Os descritores de ficheiros (file descriptors) são fundamentais para a interação entre processos e o sistema operativo.

1. **O que é um Descritor de Ficheiro?** Um descritor de ficheiro é uma representação a nível do kernel de um objeto tipo ficheiro. Este objeto pode ser um ficheiro regular, um pipe, um socket de rede, ou até mesmo um dispositivo de hardware. O descritor de ficheiro é um número inteiro que identifica unicamente um recurso aberto e permite ao processo realizar operações de leitura, escrita e manipulação desse recurso.

2. **Herança de Descritores de Ficheiro**
    - **Descritores de Ficheiro Padrão (Standard File Descriptors)**: Cada processo herda três descritores de ficheiro padrão: entrada padrão (standard input, stdin), saída padrão (standard output, stdout) e erro padrão (standard error, stderr).
        - **Entrada Padrão (stdin)**: Geralmente associado ao teclado, permite ao processo receber dados.
        - **Saída Padrão (stdout)**: Normalmente associado ao ecrã, permite ao processo enviar dados.
        - **Erro Padrão (stderr)**: Usado para saída de mensagens de erro, também geralmente associado ao ecrã.
    
    - **Herança de Todos os Descritores de Ficheiro Abertos**: Quando um processo cria um novo processo (processo filho), este novo processo herda todos os descritores de ficheiro abertos pelo processo pai no momento da criação. Isto significa que o processo filho pode continuar a usar esses descritores de ficheiro para interagir com os mesmos recursos que o processo pai.

3. **Benefícios da Herança de Descritores de Ficheiro**
    - **Eficiência**: Permite a comunicação entre processos e a continuidade do trabalho sem a necessidade de reabrir ficheiros ou outros recursos.
    - **Facilidade de Implementação**: Facilita a implementação de pipelines e outras formas de comunicação interprocessos (IPC).
    **Flexibilidade**: Permite que processos filhos executem tarefas específicas com os mesmos recursos do processo pai, como redirecionar a saída de um comando para um ficheiro ou outro programa.

---

### Criação de Processos

1. **Processos São Criados por Clonagem**: Em sistemas Unix-like, os processos são frequentemente criados através da clonagem de um processo existente usando a chamada de sistema fork. Este processo de clonagem cria uma cópia quase idêntica do processo original (processo pai).

2. **Cópia do Espaço de Endereços (Lazy Copy)**: Quando um processo é clonado, o espaço de endereços é copiado de maneira "preguiçosa" (lazy copy). Isto significa que o sistema operativo inicialmente não duplica toda a memória física; em vez disso, ele usa a técnica de copy-on-write. Apenas quando o processo filho ou pai tenta modificar uma página de memória é que uma cópia real dessa página é feita.

3. **Descritores de Ficheiro Abertos São Herdados**: Todos os descritores de ficheiro abertos pelo processo pai são herdados pelo processo filho. Isto permite que o processo filho tenha acesso aos mesmos recursos que o processo pai, como ficheiros, sockets e pipes.

---

### Execução de Processos

1. **Programas São Executados**: Após a criação do processo, um programa pode ser carregado para execução no espaço de endereços do processo. Isto é frequentemente feito com a chamada de sistema exec, que carrega um novo programa no espaço de endereços do processo existente.

2. **Substituição do Espaço de Endereços pelo Conteúdo de um Ficheiro Executável (ABI)**: Quando exec é chamado, o espaço de endereços do processo é substituído pelo conteúdo de um ficheiro executável. Este ficheiro é carregado de acordo com a Interface Binária da Aplicação (Application Binary Interface, ABI) do sistema, que define como os binários são estruturados e executados.

3. **Descritores de Ficheiro Abertos São Preservados**: Apesar da substituição do espaço de endereços, os descritores de ficheiro abertos são preservados. Isto significa que, após a execução do novo programa, o processo mantém os mesmos descritores de ficheiro abertos que herdou ou abriu antes da chamada exec.

---

### Comunicação Interprocessos (IPC)
A Comunicação Interprocessos (IPC) é essencial para a coordenação e troca de dados entre processos. Vários métodos podem ser usados para IPC, cada um com suas próprias características e usos específicos.

1. **Ficheiros (Files)**
    - **Descrição**: Os processos podem comunicar-se através de ficheiros, onde um processo escreve dados num ficheiro e outro processo lê esses dados.
    - **Usos**: Este método é simples e útil para armazenamento e comunicação de dados persistentes.
    - **Vantagens**: Fácil de implementar e utilizar.
    - **Desvantagens**: Menor eficiência e maior latência devido ao acesso ao sistema de ficheiros.

2. **IPC Tradicional/Memória Partilhada (Shared Memory)**
    - **Descrição**: Dois ou mais processos podem acessar uma área de memória comum. Isto permite uma comunicação extremamente rápida, pois os dados não precisam ser copiados entre processos.
    - **Usos**: Aplicações que requerem troca rápida de grandes quantidades de dados.
    - **Vantagens**: Alta eficiência e baixa latência.
    - **Desvantagens**: Complexidade na sincronização e gestão da concorrência.

3. **Filas de Mensagens (Message Queues)**
    - **Descrição**: Permitem a troca de mensagens entre processos através de uma fila gerida pelo kernel.
    **Usos**: Comunicação assíncrona onde a ordem das mensagens é importante.
    **Vantagens**: Simplicidade na comunicação e capacidade de priorização de mensagens.
    **Desvantagens**: Pode ter limitações de tamanho e latência comparada à memória partilhada.

4. **Semáforos (Semaphores)**
    - **Descrição**: Utilizados para controlar o acesso a recursos partilhados, sincronizando processos.
    - **Usos**: Sincronização e prevenção de condições de corrida (race conditions).
    - **Vantagens**: Eficaz na gestão de acesso concorrente.
    - **Desvantagens**: Pode ser complexo de implementar corretamente e propenso a deadlocks.

5. **Pipes (Nominais ou Não Nominais)**
    - **Descrição**: Pipes são canais de comunicação unidirecionais usados para conectar processos. Pipes não nominais (anónimos) existem apenas enquanto os processos pai e filho estão em execução, enquanto pipes nominais (nomeados) são identificados por um nome no sistema de ficheiros e podem ser usados por processos não relacionados.
    - **Usos**: Comunicação entre processos que têm uma relação hierárquica (pai-filho) ou qualquer processo (nominais).
    - **Vantagens**: Simples de usar e implementar.
    - **Desvantagens**: Limitados a comunicação unidirecional e ao mesmo sistema.

6. **Sockets (Domínios Locais ou de Rede)**
    - **Descrição**: Sockets permitem comunicação bidirecional entre processos, tanto no mesmo sistema (sockets locais) quanto em sistemas diferentes através de uma rede (sockets de rede).
    - **Usos**: Aplicações de rede e comunicação entre processos em sistemas diferentes.
    - **Vantagens**: Flexibilidade e capacidade de comunicação através de redes.
    - **Desvantagens**: Complexidade maior em comparação com pipes e outros métodos IPC.


---
###  Permissões e Modos de Ficheiros e Diretórias Unix
As permissões e modos de ficheiros e diretoria Unix são aspetos fundamentais dos sistemas operativos do tipo Unix, definindo os mecanismos de controlo de acesso para ficheiros e diretoria. Estas permissões determinam quem pode **ler**, **escrever** ou **executar** um ficheiro ou diretoria.

1. **Conformidade com POSIX**
   POSIX (Portable Operating System Interface) é uma família de normas especificadas pelo IEEE para manter a compatibilidade entre sistemas operativos. POSIX 1:2008, também conhecida como Especificação Única Unix (SUS) V4, inclui diretrizes abrangentes para permissões de ficheiros e diretorias.

2. **Tipos de Permissões**
   Cada ficheiro e diretoria tem um conjunto de permissões para três tipos de utilizadores:
   - **Proprietário (Utilizador)**: O criador do ficheiro ou diretoria.
   - **Grupo**: Um conjunto de utilizadores que partilham determinadas permissões.
   - **Outros (Mundo)**: Todos os outros utilizadores.

   As permissões são representadas em três conjuntos de três caracteres, por exemplo, rwxr-xr--.
   - **r**: Permissão de leitura
   - **w**: Permissão de escrita
   - **x**: Permissão de execução

   Permissões de **Ficheiros**:
   - **r**: Permite visualizar o conteúdo de um ficheiro.
   - **w**: Permite modificar o conteúdo de um ficheiro.
   - **x**: Permite executar o ficheiro como um programa.

   Permissões de **Diretorias**:
   - **r**: Permite listar o conteúdo do diretório.
   - **w**: Permite criar, apagar ou renomear ficheiros dentro do diretório.
   - **x**: Permite aceder (entrar) no diretório.

   As permissões também podem ser representadas numericamente usando notação octal:
   ~~~
   r = 4
   w = 2
   x = 1
   ~~~
   Por exemplo:
   - rwxr-xr-- traduz-se para 755.
   - rw-r--r-- traduz-se para 644.

3. **Modos Especiais**
   POSIX também define bits de permissão especiais.
   - **Set User ID (setuid, s)**: Executa o ficheiro com as permissões do proprietário do ficheiro.
   - **Set Group ID (setgid, s)**: Executa o ficheiro com as permissões do grupo do ficheiro.
   - **Sticky Bit (t)**:  Usado em diretorias para restringir a eliminação de ficheiros apenas ao proprietário do ficheiro.

4. **Gestão na Linha de Comandos**
   As permissões podem ser modificadas usando o comando chmod (change mode):
   - Método simbólico: **chmod u+x ficheiro** (adiciona permissão de execução para o proprietário).
   - Método numérico: **chmod 755 ficheiro** (define as permissões para rwxr-xr-x).

   Para mudar o proprietário ou grupo de um ficheiro, são usados os comandos chown e chgrp:
   - chown utilizador ficheiro
   - chgrp grupo ficheiro

---

### Utilizadores, Grupos e Senhas
1. **Identificação de Utilizadores e Grupos**
    - **User ID (UID)**: Identificação única atribuída a cada utilizador no sistema.
    - **Group ID (GID)**: Identificação única atribuída a cada grupo de utilizadores no sistema.
    - **Grupos Primários e Secundários**: Cada utilizador tem um grupo primário associado ao seu UID e pode pertencer a vários grupos secundários.

2. **Bases de Dados de Utilizadores e Grupos**
    - **Base de Dados de Utilizadores**: Armazenada em **/etc/passwd**, contém informações básicas sobre os utilizadores, incluindo o UID, GID, diretório inicial e o shell padrão. A senha criptografada é armazenada no arquivo **/etc/shadow**.
    - **Base de Dados de Grupos**: Armazenada em **/etc/group**, contém informações sobre os grupos de utilizadores, incluindo os GIDs e os utilizadores que pertencem a cada grupo.

Estas bases de dados são fundamentais para a gestão de utilizadores, grupos e permissões no sistema Unix.

---

### Controlo de Acesso a Recursos
1. **Homogeneidade**: Refere-se à consistência no tratamento de diferentes tipos de recursos e utilizadores no sistema.

2. **Simplicidade**: Os mecanismos de controlo de acesso devem ser concebidos de forma simples para facilitar a sua compreensão e gestão.

3. **Ficheiros, Diretórios e Outros Recursos**: Os mecanismos de controlo de acesso aplicam-se não apenas a ficheiros e diretorias, mas também a outros recursos do sistema, como dispositivos e serviços de rede.

4. **Propriedade**: Cada recurso tem um proprietário e um grupo associado, determinando quem pode realizar determinadas ações sobre esse recurso.

5. **Permissões**: As permissões definem quais ações podem ser realizadas por diferentes utilizadores e grupos em relação a um recurso específico, como ler, escrever ou executar.

---

### Propriedade de Objetos do Sistema de Ficheiros

1. **Proprietário de Utilizador Atribuído**
    - Cada objeto no sistema de ficheiros é atribuído a um utilizador como proprietário.
    - O proprietário de utilizador tem controlo total sobre o objeto e pode modificar as suas permissões e conteúdo, dependendo das permissões estabelecidas.

2. **Proprietário de Grupo Atribuído**
    - Além do proprietário de utilizador, cada objeto também é atribuído a um grupo como proprietário.
    - Os membros desse grupo têm permissões específicas sobre o objeto, definidas em conjunto com as permissões do proprietário de utilizador.

A atribuição de proprietários de utilizador e grupo é fundamental para o controlo de acesso eficaz e a gestão adequada dos objetos no sistema de ficheiros.

---

### Permissões Definidas Independentes
Cada classe de utilizador pode ter permissões diferentes para um arquivo ou diretório. Por exemplo, o proprietário pode ter permissão para escrever em um arquivo, enquanto os outros usuários apenas têm permissão para lê-lo.

Tanto arquivos quanto diretórios têm permissões, mas a semântica de algumas permissões pode ser ligeiramente diferente entre eles. Por exemplo, em um arquivo, a permissão de execução pode significar a capacidade de executá-lo como um programa, enquanto em um diretório, permite entrar nele.

---

### Permissoes
1. **Umask: Restrição Padrão do Utilizador nas Permissões**
O umask é uma configuração que define as permissões padrão impostas a novos arquivos e diretórios criados por um utilizador. Ele atua como uma máscara de bits, onde os bits definidos no umask são **removidos** das permissões padrão.

2. **Permissões de 12 Bits Mantidas no I-node do Recurso**
Cada recurso no sistema de ficheiros Unix é representado por um inode, que armazena informações sobre o recurso, incluindo suas permissões. As permissões são representadas por 12 bits no inode, controlando o acesso ao recurso para diferentes classes de utilizadores.

3. **Permissões Influenciam Chamadas de Sistema (Não Comandos)**
    As permissões determinam quais ações os utilizadores podem realizar em um recurso através das chamadas de sistema do kernel, como open, read, write, chmod, entre outras.
    As permissões afetam diretamente como o sistema operativo permite ou nega o acesso a um recurso.

4. **Apenas o Superutilizador Pode Modificar a Propriedade**
Somente o superutilizador (**root**) tem permissão para modificar a propriedade de um arquivo ou diretório, ou seja, o proprietário e o grupo a que pertence. Isso é crucial para garantir a integridade e segurança do sistema, evitando alterações não autorizadas na propriedade dos recursos.

5. **Apenas o Proprietário (ou Superutilizador) Pode Modificar Permissões**
Apenas o proprietário de um arquivo ou diretório, ou o superutilizador, tem permissão para modificar as suas permissões.
Isso garante que apenas aqueles com direitos adequados possam controlar quem pode acessar ou modificar o recurso.

---

### Atributos gerais
1. **Atributos gerias**
    - **Permissões**: Tipo de permissões e conjunto de permissões para proprietário, grupo e outros.
    - **Proprietário de Utilizador (u-owner)**: O utilizador proprietário do recurso.
    - **Proprietário de Grupo (g-owner)**: O grupo proprietário do recurso.
    - **Data de Criação/Modificação (c/m-date)**: Data em que o recurso foi criado ou modificado.
    - **Nome**: O nome do recurso.

2. **Atributos de Permissões**
    - **Tipo**: Indica se o recurso é um arquivo (-) ou um diretório (d).
    - **Permissões**: Representa as permissões para o proprietário, grupo e outros usuários.
    - **Set UID/GID**: Indica se o bit setuid ou setgid está definido no recurso.
    - **Sticky Bit**: Indica se o bit sticky está definido no diretório.
    - **Outros**: Pode haver outros atributos específicos do sistema.

    ~~~
    -rwxr--r--, drwxr-xr-x (arquivo e diretório, respectivamente)

    drwsrwsrwt, drwSrwSrwT (diretórios com setuid, setgid e sticky bits definidos)

    -rwxrw-r--+ (atributos adicionais especificados, como ACLs)
    ~~~

---

### Permissões: Experimentação
1. **Comandos para Manipulação de Permissões**
    - **chmod**: Utilizado para alterar as permissões de um arquivo ou diretoria.
    - **chown**: Utilizado para alterar o proprietário de um arquivo ou diretoria.
    - **chgrp**: Utilizado para alterar o grupo proprietário de um arquivo ou diretoria.

2. **Chamadas de Sistema para Operações de Arquivo**
    - **read()**: Utilizado para ler o conteúdo de um arquivo.
    - **write()**: Utilizado para escrever no conteúdo de um arquivo.
    - **exec()**: Utilizado para executar um arquivo como um programa.
    - **unlink()**: Utilizado para remover um arquivo.
    - **stat()**: Utilizado para obter informações sobre um arquivo, incluindo permissões, proprietário e grupo.

3. **Ferramenta para Rastreamento de Chamadas de Sistema**
    **strace**: Uma ferramenta de linha de comando que permite rastrear e registrar as chamadas de sistema feitas por um processo. Útil para entender quais chamadas de sistema estão sendo usadas por um programa específico e diagnosticar problemas de execução.

---

### Permissões: Experimentação
Criou-se um diretório chamado "adir" e dois arquivos dentro dele, "a" e "le", utilizando o seguinte comando:
~~~
mkdir adir && touch adir/a adir/le
~~~
Realizou-se a listagem do conteúdo do diretório "adir" utilizando os comandos ls:
~~~
ls adir
ls -l adir
ls -l adir/a adir/le
~~~
A permissão de execução do diretório "adir" foi removida com o comando:
~~~
chmod -x adir
~~~
Após essa modificação, o conteúdo do diretório "adir" foi novamente verificado, juntamente com as permissões dos arquivos. A listagem foi repetida com os comandos:
~~~
ls adir
ls -l adir
ls -l adir/a adir/le
~~~

---

# Utilizador e Grupo Real vs. Efetivo

1. **Identificação Padrão**:
Por padrão, o Identificador de Utilizador Efetivo (EUID) e o Identificador de Grupo Efetivo (EGID) são iguais ao Identificador de Utilizador Real (RUID) e ao Identificador de Grupo Real (RGID).

2. **Se SUID, SGID estiverem definidos nos recursos**
Se o bit Set UID (SUID) ou o bit Set GID (SGID) estiverem definidos em um recurso, como um arquivo executável, o EUID e o EGID serão alterados para os do proprietário do recurso quando esse recurso for executado.

3. **EUID = ID do Proprietário do Recurso**
O EUID será definido como o ID do proprietário do recurso, se o SUID estiver definido no recurso.

4. **EGID = ID do Grupo Proprietário do Recurso**
O EGID será definido como o ID do grupo proprietário do recurso, se o SGID estiver definido no recurso.


Essa distinção entre o utilizador e o grupo real e efetivo é importante para entender como as permissões são aplicadas e como a execução de determinados recursos pode alterar temporariamente a identidade do utilizador e do grupo.

---

### Atributos SUID e SGID
Os atributos **Set UID (SUID)** e **Set GID (SGID)** são úteis para permitir que um usuário **execute um programa com os privilégios do proprietário do programa**. No entanto, eles também podem ser perigosos, pois podem levar a violações do princípio de privilégios mínimos.     

Os atributos SUID e SGID permitem que um usuário execute um programa com privilégios além do necessário. Isso viola o princípio de conceder apenas os privilégios mínimos necessários para realizar uma tarefa.

Quando o atributo SUID está definido em um arquivo executável, é representado por **'s'** no lugar do bit de permissão de execução. Se o arquivo for não-executável, é representado por **'S'**.

---

### SUID & SGID em Ficheiros
1. **'S' no ID do Proprietário do Utilizador: Sem Significado**
Quando o bit SUID ('s') é definido no ID do proprietário do utilizador, não tem nenhum significado específico. Esse cenário não é comumente encontrado e não resulta em um comportamento específico.

2. **'S' no ID do Proprietário do Grupo: Bloqueio Obrigatório**
Quando o bit SGID ('s') é definido no ID do proprietário do grupo, ele indica a aplicação de bloqueio obrigatório no arquivo. Isso significa que, ao ler ou escrever no arquivo, o sistema operativo deve aplicar o bloqueio obrigatório.

3. **'s' não tem efeito em scripts... porquê?**
Quando o bit SUID ou SGID é definido em um script, como um script shell (bash, por exemplo), ele é ignorado pelo sistema operativo. Isso ocorre por motivos de segurança. Permitir que scripts sejam executados com SUID ou SGID pode ser uma séria vulnerabilidade, pois poderia permitir que um usuário execute comandos com privilégios elevados de forma não intencional ou maliciosa.

4. **Resumo disto**

Quando o bit SUID ('s') ou SGID ('s') é definido em um arquivo, isso geralmente indica que o arquivo será executado com os privilégios do proprietário do arquivo (no caso do SUID) ou do grupo proprietário do arquivo (no caso do SGID), independentemente de quem o esteja executando.

No entanto, quando se trata de scripts, como scripts shell (por exemplo, arquivos com extensão .sh), o bit SUID ou SGID é ignorado pelo sistema operacional. Isso ocorre porque permitir que scripts sejam executados com SUID ou SGID pode ser uma séria vulnerabilidade de segurança. Se um usuário mal-intencionado pudesse criar um script com SUID ou SGID, poderia executar comandos com privilégios elevados de forma não intencional ou maliciosa.

---

### SUID & SGID em Bibliotecas Compartilhadas (DLLs)
1. **Objetos Compartilhados: .so, .so.numero**
As bibliotecas compartilhadas, também conhecidas como objetos compartilhados, são arquivos que contêm funções e dados compartilhados por diferentes programas em um sistema Unix. Elas geralmente têm a extensão ".so" ou ".so.numero".

2. **Padrões do Sistema a Nível de Sistema: /etc...**
Os sistemas Unix geralmente têm padrões definidos globalmente para bibliotecas compartilhadas, armazenados em diretórios como "/etc/...".

3. **Sobrescrita: LD_LIBRARY_PATH**
O LD_LIBRARY_PATH é uma variável de ambiente que especifica uma lista de diretórios nos quais o linker dinâmico procura bibliotecas compartilhadas ao executar um programa. Ela pode ser usada para substituir os diretórios padrão de busca de bibliotecas compartilhadas.

4. **Perigoso para SUID, SGID... porquê?**
Permitir que bibliotecas compartilhadas sejam executadas com SUID ou SGID pode ser perigoso, pois elas são frequentemente utilizadas por vários programas e podem conter código potencialmente perigoso. Se um usuário mal-intencionado pudesse substituir uma biblioteca compartilhada com SUID ou SGID por uma versão maliciosa, poderia executar comandos com privilégios elevados de forma não intencional ou maliciosa.

5. **Se SUID ou SGID, então LD_LIBRARY_PATH é ignorado**
Por razões de segurança, quando um executável é marcado com SUID ou SGID, o LD_LIBRARY_PATH é ignorado. Isso significa que, mesmo que um usuário tenha modificado o LD_LIBRARY_PATH para apontar para um diretoria específica, essa diretoria não será usada para buscar bibliotecas compartilhadas quando o executável for executado com privilégios elevados.

---

### Bit Sticky em Ficheiros
O bit sticky, também conhecido como bit de texto, é um atributo de permissão que pode ser aplicado a arquivos em sistemas Unix. O bit sticky foi originalmente concebido para indicar ao sistema operacional que o código de um arquivo deve ser mantido na troca (swap) ou na memória, de modo que ele permaneça disponível para acesso rápido. Com o advento da memória virtual, que permite o mapeamento de páginas de memória para o espaço de endereçamento do processo de forma dinâmica, o bit sticky tornou-se obsoleto e é geralmente desconsiderado.

Quando o bit sticky está definido em um arquivo executável, ele é representado por **'t'** no lugar do bit de permissão de execução.
Se o arquivo for não-executável, é representado por **'T'**.

O bit sticky não tem efeito em arquivos não-executáveis. Ele era relevante apenas para arquivos cujo código precisava ser mantido na troca ou na memória para acesso rápido.

---

### SUID & SGID em Diretórios
O bit SUID (Set User ID) não tem efeito em diretorias. Ele só tem efeito em arquivos executáveis.

Em sistemas Linux e Solaris, quando o bit SGID (Set Group ID) é definido numa diretoria, o proprietário de grupo da diretoria é copiado para novos arquivos ou diretórios criados dentro dele. No entanto, isso não significa que eles herdarão as permissões do diretório pai.

A semântica do SGID em diretorias não está incluída na especificação Single UNIX Specification (SUS) V4. Portanto, seu comportamento pode variar entre diferentes sistemas operacionais Unix-like.

---

### Bit Sticky em Diretorias
Quando o bit sticky está definido em diretorias, apenas o proprietário de um recurso, o proprietário do diretório (ou o superutilizador), pode mover, renomear ou excluir o recurso. Isso significa que mesmo que outros usuários tenham permissão de escrita no diretório, eles não podem mover, renomear ou excluir os arquivos de outros usuários.

O bit sticky funciona em conjunto com as permissões de escrita da diretoria.

É uma medida de segurança para evitar que usuários não autorizados excluam ou modifiquem arquivos de outros usuários em diretorias compartilhadas, como /tmp.

---

### Listas de Controle de Acesso (ACLs)
As Listas de Controle de Acesso (ACLs) permitem definir permissões específicas para usuários e grupos individuais em arquivos e diretórios.

Para diretorias, as ACLs podem ser herdadas ou simplesmente copiadas para novos arquivos e diretórios criados dentro deles.

Embora tenha sido proposta uma especificação POSIX para ACLs, ela foi posteriormente retirada.

As ACLs fornecem uma solução para o problema de umask por diretório, permitindo ajustar as permissões de forma mais precisa para diferentes usuários e grupos.

---
### Experimentação com ACLs
Para ACLs, podem ser utilizados os comandos **setfacl** e **getfacl**. O **setfacl** é usado para definir as ACLs em arquivos e diretorias, enquanto o **getfacl** é usado para visualizar as ACLs existentes.

É importante entender a diferença entre a máscara de permissão real e efetiva ao trabalhar com ACLs. A máscara de permissão real refere-se às permissões tradicionais de usuário, grupo e outros, enquanto a máscara de permissão efetiva refere-se às permissões definidas pelas ACLs.

Quando as ACLs estão em uso, é comum ver um símbolo **'+'** após as permissões tradicionais listadas para indicar que as ACLs estão definidas para esse arquivo ou diretoria.

---
### Atributos Adicionais/Estendidos
1. **Atributos Adicionais**
Diferentes sistemas de arquivos, como NTFS e famílias ext (como ext2, ext3, ext4), suportam atributos adicionais que podem ser associados a arquivos e diretorias. No sistema de arquivos ext2, os atributos adicionais podem ser visualizados e modificados usando os comandos **lsattr** e **chattr**.

2. **Atributos Estendidos**
Os atributos estendidos permitem associar pares de nome e valor a arquivos e diretorias em sistemas de arquivos que os suportam. Eles oferecem uma maneira de armazenar metadados adicionais além das permissões tradicionais e dos atributos do sistema de arquivos. Os comandos **getfattr** e **setfattr** são usados para visualizar e definir atributos estendidos em sistemas Unix.

3. **Indicação por ' ' ou '.' após as permissões, a menos que a ACL esteja definida**
Quando atributos adicionais ou estendidos são definidos para um arquivo ou diretório, pode ser exibido um espaço (' ') ou um ponto ('.') após as permissões tradicionais para indicar sua presença. Isso ocorre quando uma ACL não está definida.

---

### Poderes de Root
Certas operações no sistema operacional, como desligamento do sistema, ligação de portas de rede e outras, podem ignorar as permissões normais de arquivo e diretoria.

Para determinar se uma operação é realizada com poderes de root, pode-se verificar se o Identificador de Utilizador Efetivo (EUID) é igual a 0, o que é o UID do root no sistema Unix.

O mecanismo de capacidades é uma solução para lidar com o problema de programas que precisam de privilégios de root apenas para realizar operações específicas. Ele permite que um programa inicie com privilégios de root, mas renuncie às capacidades que não são necessárias para realizar suas tarefas.

É uma prática de segurança recomendada minimizar os privilégios concedidos a programas e processos, a fim de reduzir a superfície de ataque e mitigar o impacto de possíveis exploits.

---

### Chroot Jail
Chroot, abreviação de "change root", é uma técnica usada em sistemas Unix e Linux para alterar o diretório raiz aparente para um processo e seus processos filhos. Isso faz com que a diretoria especificado seja tratado como a diretoria raiz do sistema de arquivos pelo processo e por quaisquer processos filhos.

Quando um processo é colocado em um chroot jail, ele e todos os processos filhos gerados por ele operam dentro do novo diretório raiz especificado.

A capacidade de usar chroot é restrita ao superutilizador (root) do sistema.

O chroot jail é frequentemente utilizado em situações como testes e desenvolvimento de software, controle e compatibilidade de dependências, recuperação do sistema e separação de privilégios.

Essa técnica é útil para isolar e limitar o acesso de um processo a apenas um subconjunto específico do sistema de arquivos, proporcionando um ambiente controlado e seguro para várias finalidades, desde o desenvolvimento de software até a execução de serviços em ambientes de produção

---

### Melhores Práticas do Chroot
1. **Mudar o diretório de trabalho para dentro do jail antes do chroot**
Garante que o processo não tenha acesso a partes indesejadas do sistema de arquivos após o chroot.

2. **Alterar o ID de usuário real/efetivo para um não-root**
Reduz o potencial de danos caso ocorra uma violação de segurança dentro do jail.

3. **Manter o mínimo possível dentro do jail**
Reduz a superfície de ataque e simplifica a gestão do jail.

4. **Ter o root como proprietário de tantos arquivos do jail quanto possível, com permissões apenas de leitura:**
Limita as capacidades do processo dentro do jail e reduz os riscos de modificação ou comprometimento de arquivos críticos.

5. **Limitar todas as permissões de arquivos e diretórios**
arante a segurança do jail, impedindo a modificação não autorizada de arquivos.

6. **Criar um script para configurar as permissões**
Automatiza e padroniza o processo de configuração do jail, reduzindo erros humanos.

7. **Executar o chroot de dentro do próprio daemon (evitar wrapping)**
Evita a necessidade de executar um wrapper em torno do daemon para iniciar o jail, o que pode introduzir complexidade e potencialmente vulnerabilidades de segurança adicionais.

8. **Carregar objetos carregados dinamicamente previamente**
Certifique-se de que todos os objetos dinamicamente carregados necessários estão disponíveis dentro do jail antes de executar o chroot. Isso evita problemas de execução devido à falta de dependências.

9. **Evitar o uso do arquivo /etc/passwd do jail:**
Ao usar um chroot, é preferível evitar o uso do arquivo /etc/passwd do jail, pois isso pode causar conflitos com o arquivo /etc/passwd do sistema host. Em vez disso, é recomendável configurar uma fonte de autenticação alternativa dentro do jail.

10. **Fechar descritores de arquivo agressivamente antes do chroot:**
Certifique-se de fechar todos os descritores de arquivo que não são necessários para o processo antes de executar o chroot. Isso ajuda a garantir que o processo não tenha acesso acidental a recursos externos após o chroot.

11. **Linkar arquivos de configuração de fora**
Para evitar a duplicação desnecessária de arquivos de configuração, é possível linkar arquivos de configuração de fora do jail para dentro do jail, desde que isso seja feito de forma segura e controlada.

12. **Atualizar variáveis de ambiente para refletir o novo root**
Após o chroot, é importante atualizar as variáveis de ambiente relevantes, como PATH, LD_LIBRARY_PATH, etc., para refletir o novo root. Isso garante que o processo encontre corretamente os recursos dentro do jail.

---

# Chroot Mínimo
Este é um procedimento mínimo para configurar um chroot. Dependendo dos requisitos específicos e do nível de segurança desejado, podem ser necessários passos adicionais, como configuração de permissões de arquivos, configuração de variáveis de ambiente, entre outros.

1. **Fechar descritores de arquivo não utilizados**
Antes de executar o chroot, feche todos os descritores de arquivo que não são necessários para o processo dentro do jail. Isso ajuda a garantir que o processo não tenha acesso a recursos externos após o chroot.

2. **Alterar o diretório de trabalho para o diretório do jail** Mude o diretório de trabalho para o diretório do jail para garantir que o processo esteja operando dentro do ambiente isolado.

3. **Executar o chroot**
Execute o comando chroot para alterar o diretório raiz aparente para o diretório do jail.

4. **Alterar o ID de usuário efetivo para um não-root:** 
Altere o ID de usuário efetivo para um ID de usuário não-root dentro do jail, reduzindo assim os privilégios do processo.

~~~
close(unused le descriptors);
chdir("jail");
chroot(".");
setuid(non-root-uid);
~~~

---
### Chroot
A chamada de sistema principal relacionada ao chroot é a **chroot()**, que é usada para alterar o diretório raiz aparente de um processo. O comando relacionado é o próprio chroot, que é usado para iniciar um shell ou um programa em um ambiente chroot.

Chroot é o precursor de várias tecnologias de virtualização e isolamento de processos, como jails no FreeBSD, Solaris Containers, Linux Containers (LXC), Docker e Linux userspaces (a partir do kernel 3.8+). Essas tecnologias estendem o conceito de chroot, fornecendo isolamento de recursos mais avançado, como isolamento de rede, isolamento de processos e gerenciamento de namespaces.

O chroot é uma técnica poderosa e fundamental em sistemas Unix para criar ambientes de execução isolados e seguros. Ele serve como a base para muitas das tecnologias de virtualização e contêineres modernas que são amplamente usadas hoje em dia.











